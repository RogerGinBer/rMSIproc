# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

C_adductAnnotation <- function(numMonoiso, numAdducts, tolerance, numMass, R_monoisitopeMassVector, R_adductMassVector, R_isotopes, R_isotopeListOrder, R_massAxis, R_peakMatrix, numPixels) {
    .Call('_rMSIproc_C_adductAnnotation', PACKAGE = 'rMSIproc', numMonoiso, numAdducts, tolerance, numMass, R_monoisitopeMassVector, R_adductMassVector, R_isotopes, R_isotopeListOrder, R_massAxis, R_peakMatrix, numPixels)
}

C_isotopeAnnotator <- function(massPeaks, massChannels, numPixels, numIso, PeakMtx, massVec, massChanVec, tolerance, scoreThreshold, ToleranceInScans) {
    .Call('_rMSIproc_C_isotopeAnnotator', PACKAGE = 'rMSIproc', massPeaks, massChannels, numPixels, numIso, PeakMtx, massVec, massChanVec, tolerance, scoreThreshold, ToleranceInScans)
}

AlignSpectrumToReference <- function(mass, ref, x, bilinear = FALSE, lagRefLow = 0.1, lagRefMid = 0.5, lagRefHigh = 0.9, iterations = 1L, lagLimitppm = 200, fftOverSampling = 2L) {
    .Call('_rMSIproc_AlignSpectrumToReference', PACKAGE = 'rMSIproc', mass, ref, x, bilinear, lagRefLow, lagRefMid, lagRefHigh, iterations, lagLimitppm, fftOverSampling)
}

#' MergeTwoMassAxis.
#' 
#' Merges two mass axis in a single one using an apropiate bin size.
#' The resulting mass axis will display a bin size equal to the minimum of two supplied vectors. 
#' The bin size is calculated relative to the m/z for better accuracy.
#' The resulting mass axis range is calculated using the common range between the two mass axis.
#' If there is no overlao between the two mass axis range an error will be raised.
#' 
#' @param mz1 the first mass axis to merge.
#' @param mz2 the second mass axis to merge.
#' 
#' @return a list containing the common mass axis that represents mz1 and mz1 accurately and a boolean indicating if and error was raised.
#' @export
#' 
MergeTwoMassAxis <- function(mz1, mz2) {
    .Call('_rMSIproc_MergeTwoMassAxis', PACKAGE = 'rMSIproc', mz1, mz2)
}

AverageSpectrumC <- function(fileNames, massChannels, numRows, dataType, numOfThreads) {
    .Call('_rMSIproc_AverageSpectrumC', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType, numOfThreads)
}

FullImageBitDepthReduction <- function(fileNames, massChannels, numRows, dataType, numOfThreads, NoiseWinSize = 16L) {
    invisible(.Call('_rMSIproc_FullImageBitDepthReduction', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType, numOfThreads, NoiseWinSize))
}

SpectrumBitDepthReduction <- function(data, NoiseWinSize = 16L) {
    .Call('_rMSIproc_SpectrumBitDepthReduction', PACKAGE = 'rMSIproc', data, NoiseWinSize)
}

FullImageAlign <- function(fileNames, mass, refSpectrum, numRows, dataType, numOfThreads, AlignmentBilinear = FALSE, AlignmentIterations = 3L, AlignmentMaxShiftPpm = 200L, RefLow = 0.0, RefMid = 0.5, RefHigh = 1.0, OverSampling = 2L) {
    .Call('_rMSIproc_FullImageAlign', PACKAGE = 'rMSIproc', fileNames, mass, refSpectrum, numRows, dataType, numOfThreads, AlignmentBilinear, AlignmentIterations, AlignmentMaxShiftPpm, RefLow, RefMid, RefHigh, OverSampling)
}

FullImagePeakPicking <- function(fileNames, mass, numRows, dataType, numOfThreads, SNR = 5, WinSize = 10L, InterpolationUpSampling = 10L, doBinning = TRUE, binningTolerance = 100, binningFilter = 0.9, binningIn_ppm = TRUE, exportPeakList = FALSE) {
    .Call('_rMSIproc_FullImagePeakPicking', PACKAGE = 'rMSIproc', fileNames, mass, numRows, dataType, numOfThreads, SNR, WinSize, InterpolationUpSampling, doBinning, binningTolerance, binningFilter, binningIn_ppm, exportPeakList)
}

ReplacePeakMatrixZeros <- function(PeakMatrix, fileNames, mass, numRows, dataType, numOfThreads, WinSize = 10L, InterpolationUpSampling = 10L) {
    .Call('_rMSIproc_ReplacePeakMatrixZeros', PACKAGE = 'rMSIproc', PeakMatrix, fileNames, mass, numRows, dataType, numOfThreads, WinSize, InterpolationUpSampling)
}

FullImageSmoothing <- function(fileNames, massChannels, numRows, dataType, numOfThreads, SmoothingKernelSize = 5L) {
    invisible(.Call('_rMSIproc_FullImageSmoothing', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType, numOfThreads, SmoothingKernelSize))
}

#' NoiseEstimationFFTCosWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
#' @export
NoiseEstimationFFTCosWin <- function(x, filWinSize = 40L) {
    .Call('_rMSIproc_NoiseEstimationFFTCosWin', PACKAGE = 'rMSIproc', x, filWinSize)
}

#' NoiseEstimationFFTExpWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
#' @export
NoiseEstimationFFTExpWin <- function(x, filWinSize = 40L) {
    .Call('_rMSIproc_NoiseEstimationFFTExpWin', PACKAGE = 'rMSIproc', x, filWinSize)
}

#' NoiseEstimationFFTCosWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
#' @export
NoiseEstimationFFTCosWinMat <- function(x, filWinSize = 40L) {
    .Call('_rMSIproc_NoiseEstimationFFTCosWinMat', PACKAGE = 'rMSIproc', x, filWinSize)
}

#' NoiseEstimationFFTExpWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
#' @export
NoiseEstimationFFTExpWinMat <- function(x, filWinSize = 40L) {
    .Call('_rMSIproc_NoiseEstimationFFTExpWinMat', PACKAGE = 'rMSIproc', x, filWinSize)
}

MergePeakMatricesC <- function(PeakMatrices, binningTolerance = 100, binningFilter = 0.01) {
    .Call('_rMSIproc_MergePeakMatricesC', PACKAGE = 'rMSIproc', PeakMatrices, binningTolerance, binningFilter)
}

#' CPeakList2PeakMatrix.
#' 
#' Convert's an R peak list into a peak matrix.
#' @param RpeakList R peak list.
#' @param the tolerance used to merge peaks to the same bin. It is recomanded to use the half of peak width in ppm units. 
#' @param BinFilter the peaks bins non detected in at least the BinFitler*TotalNumberOfPixels spectra will be deleted.
#' @param BinToleranceUsingPPM if True the peak binning tolerance is specified in ppm, if false the tolerance is set using scans.
#' @return peak matrix.
#' 
CPeakList2PeakMatrix <- function(RpeakList, BinTolerance = 5, BinFilter = 0.1, BinToleranceUsingPPM = TRUE) {
    .Call('_rMSIproc_CPeakList2PeakMatrix', PACKAGE = 'rMSIproc', RpeakList, BinTolerance, BinFilter, BinToleranceUsingPPM)
}

#'LoadPeakMatrix.
#'
#'Loads a binned peaks matrix from HDD.
#'
#'@param path full path to directory from where data must be loaded.
#'@return  an R List containing intensity, SNR and area matrices, mass axis vector and if available the normalizations data.frame.
#'
LoadPeakMatrixC <- function(path) {
    .Call('_rMSIproc_LoadPeakMatrixC', PACKAGE = 'rMSIproc', path)
}

#'StorePeakMatrix.
#'
#'Stores a binned peaks matrix to HDD.
#'
#'@param path full path to directory where data must be stored.
#'@param mat an R List containing intensity, SNR and area matrices the mass axis vector and an R data.frame containing a normalization on each column.
#'
StorePeakMatrixC <- function(path, mat) {
    invisible(.Call('_rMSIproc_StorePeakMatrixC', PACKAGE = 'rMSIproc', path, mat))
}

#' DetectPeaks_C.
#' 
#' Detect peaks from a Rcpp::NumericVector object and returns data in a R matrix.
#' This method is only exported to be use by R function DetectPeaks which is an actual R function.
#' The returned peak positions follows C indexing style, this is starts with zero.
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param SNR Only peaks with an equal or higher SNR are retained.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumerixMatrix of 5 rows corresponding to: mass, intensity of the peak, SNR, area and binSize.
#' 
DetectPeaks_C <- function(mass, intensity, SNR = 5, WinSize = 20L, UpSampling = 10L) {
    .Call('_rMSIproc_DetectPeaks_C', PACKAGE = 'rMSIproc', mass, intensity, SNR, WinSize, UpSampling)
}

#' TestPeakInterpolation_C.
#' 
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param peakIndex the location of the peak to interpolate in the spectrum.  
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' @param useHanning if hanning windowing must be used befor interpolation.
#' @param Iterations number of iterations to perform. This is just for testing interpolation efficiency
#' 
#' @return a NumerixVector with the FFT interpolated peak shape.
#' 
TestPeakInterpolation_C <- function(mass, intensity, peakIndex, WinSize = 20L, UpSampling = 10L, useHanning = FALSE, Iterations = 1L) {
    .Call('_rMSIproc_TestPeakInterpolation_C', PACKAGE = 'rMSIproc', mass, intensity, peakIndex, WinSize, UpSampling, useHanning, Iterations)
}

#' TestHanningWindow.
#' 
#' Method to test the implementation of Hanning window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Hanning Window.
#' 
TestHanningWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('_rMSIproc_TestHanningWindow', PACKAGE = 'rMSIproc', mass, WinSize, UpSampling)
}

#' TestAreaWindow.
#' 
#' Method to test the implementation of Area window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Area Window.
#' 
TestAreaWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('_rMSIproc_TestAreaWindow', PACKAGE = 'rMSIproc', mass, WinSize, UpSampling)
}

PrintrMSIObjectInfo <- function(fileNames, massChannels, numRows, dataType) {
    invisible(.Call('_rMSIproc_PrintrMSIObjectInfo', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType))
}

LoadrMSIDataCube <- function(fileNames, massChannels, numRows, dataType, cubeSel) {
    .Call('_rMSIproc_LoadrMSIDataCube', PACKAGE = 'rMSIproc', fileNames, massChannels, numRows, dataType, cubeSel)
}

#' Smoothing_SavitzkyGolay.
#' 
#' Computes the Savitzky-Golay smoothing of a vector x using a filter size of sgSize.
#' @param x the data vector to smooth.
#' @param sgSize valid values are: 5, 7, 9, 11, 13, 15.
#' @return the smoothed data vector.
Smoothing_SavitzkyGolay <- function(x, sgSize = 5L) {
    .Call('_rMSIproc_Smoothing_SavitzkyGolay', PACKAGE = 'rMSIproc', x, sgSize)
}

